
　　／■　■‾‾■　■‾‾■　■＼　＿　■　μITRON 3.0 仕様　リアルタイム・マルチタスクモニタ
　／　■＿＿■　■＿■　■＿＿■　＼‾　■　Copyright (c) Mineyuki Kimoto 1994

                             Version 1.01.00

　このドキュメントはＡＳＵＲＡ−Ｉのカーネルである

a--w lh5:1M 0FB4    52289    13046  24.9% 94-09-18 17:08:22 asura_i.asm
a--w lh5:1M 7F10     8849     2609  29.5% 94-09-18 17:50:56 asura_i.sys

並びに開発用インクルードファイル

a--w lh5:1M CC81     8985     2527  28.1% 94-07-18 11:04:54 asura_i.inc

に関する説明です。



　ASURA-I は、μITRON 3.0 に準拠した、リアルタイム・マルチタスクモニタ
です。このシステムの最大の特徴は、MS-DOS上でデバイスドライバとして常駐
する、という点です。すなわち、通常のアプリケーションからはもちろんのこ
と、常駐プログラムや他のデバイスドライバからもASURA-I のシステムコール
を使用することが可能です。

　ASURA-I を常駐させるには、config.sysで組み込む方法と、adddrvコマンド
で組み込む方法とがあります。config.sysで組み込むと、システム起動時に自
動的に常駐することができますが、メモリを占有し続ける・再初期化できない
という欠点があります。次の一行をconfig.sysに追加すると、次の起動時から
自動的に常駐するようになります（必要であれば、asura_i.sys の存在するディ
レクトリへのパスも記述して下さい）。

device=asura_i.sys

なお、ASURA-I の自動常駐を中止するには、config.sysからこの一行を抹消し
て下さい。

　また、adddrvコマンドで組み込むと、リセットするたびに組み込む必要があ
りますが、不必要なときに常駐を解除できる点や、開発途中などで一旦常駐解
除して再度adddrvすることで初期化できるという長所があります。adddrvで組
み込むには、まずasura_i.dev というテキストファイルを作成し、その中に前
記の一行を入れておきます。次に、

adddrv asura_i.dev

を実行すると、ASURA-I が組み込まれます。常駐を解除するときはdeldrvコマ
ンドを実行します。



　現在のASURA-I （version 1.01.00 ）でサポートされているシステムコール
は次の通りです。

タスク管理　　 cre_tsk　del_tsk
　　　　　　　 sta_tsk　ext_tsk　exd_tsk　ter_tsk
　　　　　　　 dis_dsp　ena_dsp
　　　　　　　 chg_pri　rot_rdq
　　　　　　　 get_tid　ref_tsk
　　　　　　　 rel_wai
タスク付属同期 slp_tsk　wup_tsk　can_wup
　　　　　　　 sus_tsk　rsm_tsk frsm_tsk
同期通信　　　 cre_sem　del_sem　sig_sem　wai_sem preq_sem  ref_sem
　　　　　　　 cre_flg　del_flg　clr_flg　set_flg　wai_flg　pol_flg  ref_flg
　　　　　　　 cre_mbx  del_mbx  snd_msg  rcv_msg prcv_msg  ref_mbx
割り込み管理　 def_int (loc_cpu　unl_cpu  ret_int)
システム管理　 get_ver

　それぞれのシステムコールについては、μITRON 3.0 標準ハンドブックや、
付属のASURA_I.INC ファイルをご覧いただくとお分かりいただけると思います
ので、ここでは仕様と異なる点や実装依存の点を中心に解説していきます。

　　・システムコールの呼出方法

　ASURA_I.INC の冒頭に記述がありますが、機能番号をAXレジスタに、その他
のパラメータを然るべきレジスタに入れ、int 62h でシステムコールを発行し
ます。割り込みの禁止／許可の状態はシステムコール実行中も維持されます。

　但し、loc_cpu 、unl_cpu 、ret_int に関しては特別な実装となっておりま
すので、ASURA_I.INC を参照して下さい。

　　・cre_tsk のTA_HLNG 属性について

　cre_tsk システムコールでTA_HLNG 属性を指定した場合、該当のタスクはＣ
言語で記述されているとして初期値を設定します。

　TA_ASM属性の場合は、ASURA-I 内部のスタック領域（１タスクあたり512 バ
イト）を使用します。セグメントレジスタの初期値はCS=DS=ESとなっており、
com 形式の実行ファイルの起動と同等になっています。

　TA_HLNG 属性の場合は、stack で指定した領域に確保されたスタックを使用
します。Ｃ言語アプリケーション側であらかじめスタック領域を確保し、その
最後尾をstack とすることで、ASURA-I はセグメントレジスタをDS=ES=SSに設
定します。この場合、そのタスク用にASURA-I 内部に確保されているスタック
領域は全く使用されません。

　いずれの場合でも、アプリケーション側でSS:SP を変更しても全く問題あり
ません。

　　・ref_??? システムコールについて

　ref_tsk 、ref_sem 、ref_flg 、ref_mbx の各システムコールに関しては、
いくつかの工夫があります。

　まず、unuid （un-use ID ）というパラメータを受け取ることができますが、
これはそれぞれのオブジェクト（タスク・セマフォ・イベントフラグ・メール
ボックス）の中でまだ使用されていないIDを示します。これを利用することで、
複数の常駐プログラム間でIDの競合が起きるのを防ぐことができます。

　具体的な利用方法としては、ID=1に対してref_??? を発行してE_NOEXS になっ
たらID=1は空き、E_OKになったらunuid を参照するとよいでしょう（タスクの
場合は、いきなりID=0でref_tsk を発行する方法もあります）。なお、空きID
が１つもない場合、unuid=0 が返ります。

　次にref_mbx ですが、86系のCPU ではアドレスでNADR（メッセージなし）を
渡すのが困難なため、着信メッセージ数を表すmsgcntを用意し、メッセージ本
体は後方に格納しています。また、メールボックス全体の空きメッセージキュー
数をmbxfreに与えています。



　その他、仕様については以下の通りです（フリーＩＴＲＯＮ大百科と同文）。

　◆仕様◆

　・タスク
　　　tskid の範囲：１〜６３　（システムタスクは未サポート）
　　　優先度　　　：１〜３１
　　　wupcnt最大値：２５４固定
　　　suscnt最大値：２５５固定
　　　タスク状態　：run. ready, wait, suspend, wait-suspend, dormant,
　　　　　　　　　　 no-exist
　　　スタック容量：５１２バイト固定（ＡＳＵＲＡ−Ｉ常駐時に確保）

　・セマフォ
　　　semid の範囲：１〜３１　（システムセマフォは未サポート）
　　　semcnt最大値：２５５固定
　　　isemcnt 　　：生成時に設定可
　　　属性　　　　：TA_TFIFOのみ

　・イベントフラグ
　　　flgid の範囲：１〜３１　（システムイベントフラグは未サポート）
　　　ビット幅　　：１６ビット固定（ＤＩレジスタ）
　　　iflgptn 　　：生成時に設定可
　　　属性　　　　：TA_WSGL／TA_WMULを生成時に選択可
　　　待ちモード　：TWF_ANDW／TWF_ORW・TWF_CLRを選択可

　・メールボックス
　　　mbxid の範囲：１〜３１　（システムメールボックスは未サポート）
　　　属性　　　　：TA_TFIFO・TA_MFIFOのみ
　　　パケット形式：ＥＳ：ＳＩがそのまま渡される
　　　バッファ形式：リングバッファ
　　　バッファ容量：全メールボックスを通して６４メッセージ


　◆仕様／割り込み関係◆

　割り込み関係は、一般的ではないインプリメントになっています。

　まず割り込みハンドラは、タスクのスタックを利用します。多重割り込みに
は対応していません。ret_intは別ベクトルの割り込みになりますが、割り込
みハンドラ内でタスクの切り替えをしていなければ、iretで終了してかまいま
せん。

　ＡＳＵＲＡ−Ｉは、「タスクによる割り込み禁止状態」と「割り込みハンド
ラ実行状態」を等価にみていますので、割り込みを禁止するだけでディスパッ
チも同時に禁止されます。従って、loc_cpuやunl_cpuはマクロを用いて、それ
ぞれ「cli」「sti/ena_dsp」として実装します。ena_dspは強制的にディスパッ
チするために使用しますので、タスクを切り替えるようなシステムコールを発
行しなければena_dspは不要です。

　これによって「dis_dsp〜ena_dsp」の中に「cli（割り込み禁止）〜sti（割
り込み許可）」を入れることができ、従来のプログラムから移行しやすくなっ
ています。

　ただし、この実装では割り込みの禁止／許可の際のオーバーヘッドは少なく
なりますが、逆にインプリメントにおいていくつかの制限がでてしまっていま
す。それは、「割り込みハンドラ実行中」か「割り込み禁止状態でタスクを実
行中」か区別ができないためです。loc_cpuやunl_cpuをシステムコールとして
実装すれば回避できる問題ですが、今回はこのようなインプリメントにしまし
た。


　◆インプリメント上の特徴◆

　まず、上記の割り込み関係が１つの特徴です。もう一つの大きな特徴は、
suspend状態のタスクの取扱いです。

　一般的には、suspend状態のタスクはレディキューからはずされ、resumeし
た時にレディキューに戻されますが、これだとsuspend前のレディキューの状
態に回復しない可能性があります。

　そこでＡＳＵＲＡ−Ｉではsuspend状態のタスクをレディキュー内に残し、
タスク切り替えの際に読みとばすようにしています。速度の低下は否めません
が、それでもある程度の速さは確保したつもりです。


　◆インプリメント上の制約◆

　・ter_tsk は、割り込みハンドラからはいつでも実行できるとは限りません
（たまたま実行中タスクを指定した場合、e_obj になります）。

　・wup_tsk は、自タスクに対して発行してもエラーになりません（仕様書で
はe_obj になることが要求されています）。

　・sus_tsk は、自タスクに対して発行してもエラーにならず、しかもすぐに
はディスパッチしません（これは処理の高速化のためですが、ena_dsp などで
レディキューを走査したときに反映されます）。

　・割り込みハンドラ内からget_tidを発行した場合、実行中のタスクのidが
返ります（仕様書では-1を返すことが要求されています）。

　・割り込みハンドラ内で割り込みを許可することはできません（86系のＣＰＵ
では自動的に割り込み禁止になりますので、そのままにしておいて下さい）。
もし割り込みを許可した場合、それ以降の割り込みハンドラが実行されなくな
るおそれがあります。

　以上５点は、割り込みハンドラに起因する問題点です。

　・ディスパッチ禁止状態（割り込み禁止状態・割り込みハンドラ実行中を含
む）から、実行中タスクと同じ優先度に対して２回以上rot_rdqを発行した場
合、２回目以降のrot_rdqは無視されます（一旦ディスパッチすれば正常にな
ります）。

　・suspend状態のタスクが存在する優先度に対してrot_rdqを発行した場合、
見かけ上レディキューを回転しない場合があります。

　以上２点は、suspend状態のタスクをレディキューに取り込んでいることに
よるものです。



　◆最後に◆
 
　インプリメントやサンプルプログラムなど、多くの面で未熟ではありますが、
これからもがんばっていきたいと思っています。また最後になりましたが、い
ままでＡＳＵＲＡ−Ｉを使って下さった方々　ＴＲＯＮというすばらしい仕様
を開発・公開し、この瞬間も磨き続けていらっしゃる方々にこの場をお借りし
てお礼を申し上げたいと思います。特に、電子メールでの質問に丁寧なお返事
を下さった高田先生、ＴＲＯＮを提唱された坂村先生、私がＴＲＯＮに出会う
きっかけを作って下さったパーソナルメディア社の皆さん、そしてもちろん
ＩＴＲＯＮ専門委員会の皆さん、そのほか多くの皆さん、本当にありがとうご
ざいました。
